package router

import (
	"errors"
	"fmt"
	"sort"
	"strings"
)

var (
	// PathDelimeter определяет разделитель пути.
	PathDelimeter = "/"
	// NamedParamFlag используется для определения именованного параметра
	// в пути.
	NamedParamFlag = byte(':')
	// CatchAllParamFlag используется для определения динамического именованного
	// параметра пути.
	CatchAllParamFlag = byte('*')
	// Splitter нормализует путь и возвращает его в виде частей. При желании, вы
	// можете заменить эту функцию на свою.
	Splitter = func(url string) []string {
		return strings.SplitAfter(strings.TrimPrefix(url, PathDelimeter),
			PathDelimeter)
	}
)

// Paths описывает структуру для быстрого выбора обработчиков по пути запроса.
// Поддерживает как статические пути, так и пути с параметрами.
type Paths struct {
	// хранилище статических путей, без параметров;
	// в качестве ключа используется полный путь
	static map[string]interface{}
	// хранит информацию о путях с параметрами;
	// в качестве ключа используется общее количество элементов пути
	fields map[uint16]records
	// максимальное количество частей пути во всех определениях
	maxParts uint16
	// позиция, в которой встречается самый ранний динамический параметр
	catchAll uint16
}

// Add добавляет новый обработчик для указанного пути. В описании пути можно
// использовать именованные параметры (начинаются с символа ':') и завершающий
// именованный параметр (начинается с '*'), который указывает, что URL может
// быть длиннее. В последнем случае вся остальная часть пути будет включена
// в данный параметр. Параметр со звездочкой, если указан, должен быть самым
// последним параметром пути.
//
// Возвращает ошибку, если обработчик не определен (nil), если количество
// элементов пути в URL больше 32768 или параметр со звездочкой используется не
// в самом последнем элементе пути.
//
// ВНИМАНИЕ! При добавлении пути не проверяется его уникальность с точки зрения
// именованных параметров. Поэтому вполне возможно добавить два разных
// обработчика для одного и того же пути. Например:
// 	/:user/:id/:name
// 	/:user/:name/:id
// В этом случае ошибки не произойдет: просто вызываться будет первый
// добавленный обработчик, а другой никогда не будет вызван.
//
// С другой стороны, совершенно корректно отрабатывается следующая ситуация:
// 	/:user/:name
// 	/:user/test
func (r *Paths) Add(url string, handler interface{}) error {
	if handler == nil {
		return errors.New("nil handler")
	}
	parts := Splitter(url) // нормализуем путь и разбиваем его на части
	// проверяем, что количество получившихся частей не превышает максимально
	// поддерживаемое количество
	level := uint16(len(parts)) // всего элементов пути
	if level > (1<<15 - 1) {
		return fmt.Errorf("path parts overflow: %d", len(parts))
	}
	// считаем количество параметров в определении пути
	var params uint16
	for i, value := range parts {
		if value == "" {
			continue // пропускаем пустые пути
		}
		switch value[0] {
		case NamedParamFlag:
			params++ // увеличиваем счетчик параметров
		case CatchAllParamFlag:
			// такой параметр должен быть самым последним в определении путей
			if uint16(i) != level-1 {
				return errors.New("catch-all parameter must be last")
			}
			params |= 1 << 15 // взводим флаг динамического параметра
			// запоминаем позицию самого раннего встреченного динамического
			// параметра во всех добавленных путях
			if r.catchAll == 0 || r.catchAll > level {
				r.catchAll = level
			}
		}
	}
	// если в пути нет параметров, то добавляем в статические обработчики
	if params == 0 {
		if r.static == nil {
			r.static = make(map[string]interface{})
		}
		r.static[strings.Join(parts, "")] = handler
		return nil
	}
	// запоминаем максимальное количество элементов пути во всех определениях
	if r.maxParts < level {
		r.maxParts = level
	}
	// инициализируем динамические пути, если не сделали этого раньше
	if r.fields == nil {
		r.fields = make(map[uint16]records)
	}
	// добавляем в массив обработчиков с таким же количеством параметров
	r.fields[level] = append(r.fields[level], &record{params, parts, handler})
	sort.Stable(r.fields[level]) // сортируем по количеству параметров
	return nil
}

// Lookup возвращает обработчик и список именованных параметров с их значениям.
// Если подходящего обработчика не найдено, то возвращается nil.
func (r *Paths) Lookup(url string) (interface{}, Params) {
	parts := Splitter(url) // нормализуем путь и разбиваем его на части
	// сначала ищем среди статических путей; если статические пути не
	// определены, то пропускаем проверку
	if r.static != nil {
		if handler, ok := r.static[strings.Join(parts, "")]; ok {
			return handler, nil
		}
	}
	// если пути с параметрами не определены, то на этом заканчиваем проверку
	if r.fields == nil {
		return nil, nil
	}
	length := uint16(len(parts)) // вычисляем количество элементов пути
	// наши определения могут быть короче, если используются catchAll параметры,
	// поэтому вычисляем с какой длины начинать
	var total uint16
	// если длина запроса больше максимальной длины определений, то нужно
	// замахиваться на меньшее...
	if length > r.maxParts {
		// если нет динамических параметров, то ничего и не подойдет,
		// потому что наш запрос явно длиннее
		if r.catchAll == 0 {
			return nil, nil
		}
		total = r.maxParts // начнем с максимального определения пути
	} else {
		total = length // наш запрос короче самого длинного определения
	}
	// запрашиваем список обработчиков для такого же количества элементов пути
	for l := total; l > 0; l-- {
		records := r.fields[l] // получаем определения путей для данной длины
		// если обработчики для такой длины пути не зарегистрированы, то...
		if len(records) == 0 {
			// проверяем, что на этом уровне динамические пути еще встречаются
			if l < r.catchAll {
				break // больше нет динамических параметров дальше
			}
			// переходим к более короткому пути
			continue
		}
	nextRecord:
		// обработчики есть — перебираем все записи с ними
		for _, record := range records {
			// если наш путь длиннее обработчика, а он не содержит catchAll
			// параметра, то он точно нам не подойдет
			if l < length && record.params>>15 != 1 {
				continue
			}
			// здесь мы будем собирать значения параметров к данному запросу
			// если ранее они были не пустые от другого обработчика, то
			// сбрасываем их
			var params Params
		params:
			// перебираем все части пути, заданные в обработчике
			for i, part := range record.parts {
				switch part[0] {
				case byte(':'): // это одиночный параметр
					params = append(params, Param{
						// убираем ':' в начале и возможный '/' в конце
						Key: strings.TrimSuffix(part[1:], PathDelimeter),
						// элемент пути без возможного '/' в конце
						Value: strings.TrimSuffix(parts[i], PathDelimeter),
					})
					continue // переходим к следующему элементу пути
				case byte('*'): // это параметр, который заберет все
					params = append(params, Param{
						Key: part[1:], // исключаем '*' из имени
						// добавляем весь оставшийся путь
						Value: strings.Join(parts[i:], ""),
					})
					break params // больше ловить нечего — нашли
				}
				// статическая часть пути не совпадает с запрашиваемой
				if part != parts[i] {
					// переходим к следующему обработчику
					continue nextRecord
				}
			}
			// возвращаем найденный обработчик и заполненные параметры
			return record.handler, params
		}
	}
	// сюда мы попадаем, если так ничего подходящего и не нашли
	return nil, nil
}

// Path возвращает список элементов пути, связанных с данным обработчиком.
// Если обработчик связан с несколькими путями, то вернется самый первый.
func (r *Paths) Path(handler interface{}) []string {
	// перебираем статические пути
	for url, h := range r.static {
		if h == handler {
			return Splitter(url) // нашли нужный адрес - возвращаем элементы пути
		}
	}
	// перебираем все пути с параметрами
	for _, records := range r.fields {
		for _, record := range records {
			// сравниваем адреса методов
			if handler == record.handler {
				return record.parts // возвращаем элементы пути
			}
		}
	}
	return nil // данный обработчик не зарегистрирован
}
